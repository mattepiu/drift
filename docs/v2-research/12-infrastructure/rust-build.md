# Rust Build System

## Location
`crates/` — Rust workspace

## Workspace Structure
```toml
[workspace]
resolver = "2"
members = ["drift-core", "drift-napi"]
```

### drift-core
The analysis engine. Compiles as both `cdylib` (for NAPI) and `rlib` (for Rust consumers).

### drift-napi
NAPI-RS bindings that expose drift-core to Node.js.

## Cargo Dependencies

### Parsing
- `tree-sitter` 0.23 + language grammars for 10 languages
- Languages: TypeScript, JavaScript, Python, Java, C#, PHP, Go, Rust, C++, C

### File System
- `walkdir` 2 — Directory traversal
- `ignore` 0.4 — .gitignore-aware walking
- `globset` 0.4 — Glob pattern matching

### Parallelism
- `rayon` 1.10 — Data parallelism

### Storage
- `rusqlite` 0.31 (bundled) — SQLite with bundled amalgamation

### Hashing
- `xxhash-rust` 0.8 (xxh3) — Fast content hashing
- `rustc-hash` 2 — Fast HashMap

### Serialization
- `serde` 1 (derive) + `serde_json` 1

### Error Handling
- `thiserror` 1 — Derive Error trait
- `anyhow` 1 — Flexible error handling

### Other
- `regex` 1 — Pattern matching
- `once_cell` 1 — Lazy initialization
- `smallvec` 1.13 — Stack-allocated small vectors

### NAPI
- `napi` 2 (async, serde-json) — Node.js bindings
- `napi-derive` 2 — Proc macros
- `napi-build` 2 — Build script

## Release Profile
```toml
[profile.release]
lto = true          # Link-time optimization
codegen-units = 1   # Single codegen unit for max optimization
opt-level = 3       # Maximum optimization
```

## NAPI Bridge Exports
The `drift-napi` crate exposes these functions to JavaScript:

| Function | Purpose |
|----------|---------|
| `scan()` | Parallel file scanning |
| `parse()` | Source code parsing (10 languages) |
| `buildCallGraph()` | Call graph construction (SQLite) |
| `scanBoundaries()` | Data boundary detection |
| `analyzeCoupling()` | Module coupling analysis |
| `analyzeTestTopology()` | Test coverage analysis |
| `analyzeErrorHandling()` | Error handling gap detection |
| `analyzeReachability()` | Forward reachability |
| `analyzeInverseReachability()` | Inverse reachability |
| `analyzeConstants()` | Constants and secret detection |
| `analyzeEnvironment()` | Environment variable extraction |
| `analyzeWrappers()` | Wrapper pattern detection |
| `analyzeUnified()` | Combined pattern detection |
| `version()` | Version string |
| `supportedLanguages()` | Language list |

## TypeScript Type Definitions (`index.d.ts`)
Auto-generated by NAPI-RS. Key types:

| Type | Fields |
|------|--------|
| `JsScanResult` | root, files[], stats, errors[] |
| `JsScanConfig` | root, patterns[], extraIgnores, computeHashes, maxFileSize, threads |
| `JsParseResult` | language, functions[], classes[], imports[], exports[], calls[], errors[] |
| `JsFunctionInfo` | name, qualifiedName, parameters[], returnType, isExported, isAsync, startLine, endLine, decorators[], docComment |
| `JsClassInfo` | name, extends, implements[], isExported, startLine, endLine, decorators[], properties[] |
| `JsImportInfo` | source, named[], default, namespace, isTypeOnly, line |
| `JsExportInfo` | name, isDefault, isTypeOnly, source |
| `JsCallSite` | callerName, calleeName, line, column, isAsync, isDynamic |

## Cross-Platform Build
Handled by `native-build.yml` workflow. See [ci-cd.md](./ci-cd.md).

### Platform Packages
Each platform gets its own npm package under `crates/drift-napi/npm/`:
- `darwin-x64/` — macOS Intel
- `darwin-arm64/` — macOS Apple Silicon
- `win32-x64-msvc/` — Windows x64
- `linux-x64-gnu/` — Linux x64
- `linux-arm64-gnu/` — Linux ARM64

Main package uses `optionalDependencies` to pull the right platform binary.

## Benchmarks
```toml
[[bench]]
name = "parsing"
harness = false

[[bench]]
name = "full_pipeline"
harness = false
```
Uses `criterion` 0.5 for statistical benchmarking.

## v2 Considerations
- This IS the v2 core — expand Rust crate with more analysis
- Add more crate members: `drift-cortex`, `drift-mcp-core`, `drift-patterns`
- Consider workspace-level feature flags for optional analyzers
- NAPI bridge grows as more analysis moves to Rust
- Benchmark suite should expand with each new analyzer
- Consider `wasm-pack` target for browser-based analysis
