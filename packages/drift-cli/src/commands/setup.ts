/**
 * drift setup — first-time interactive wizard.
 *
 * Creates drift.toml with sensible defaults and initializes drift.db.
 */

import type { Command } from 'commander';
import { loadNapi } from '../napi.js';
import * as fs from 'node:fs';
import * as path from 'node:path';
import { CortexClient } from '@drift/cortex';

/** Default drift.toml content. */
const DEFAULT_DRIFT_TOML = `# Drift configuration
# Generated by drift setup

[scan]
include = ["src/**", "lib/**", "app/**"]
exclude = ["node_modules/**", "dist/**", "build/**", ".git/**", "vendor/**"]

[policy]
mode = "standard"  # strict | standard | lenient

[gates]
pattern-compliance = { enabled = true, threshold = 80 }
constraint-verification = { enabled = true }
security-boundaries = { enabled = true }
test-coverage = { enabled = true, threshold = 60 }
error-handling = { enabled = true }
regression = { enabled = true }

[reporters]
formats = ["console", "json"]
`;

export function registerSetupCommand(program: Command): void {
  program
    .command('setup')
    .description('Initialize Drift in the current project — creates drift.toml and drift.db')
    .option('--force', 'Overwrite existing configuration')
    .action(async (opts: { force?: boolean }) => {
      const projectRoot = process.cwd();
      const configPath = path.join(projectRoot, 'drift.toml');
      const driftDir = path.join(projectRoot, '.drift');

      try {
        // Check for existing config
        if (fs.existsSync(configPath) && !opts.force) {
          process.stdout.write(
            'drift.toml already exists. Use --force to overwrite.\n',
          );
          process.exitCode = 0;
          return;
        }

        // Create .drift directory
        if (!fs.existsSync(driftDir)) {
          fs.mkdirSync(driftDir, { recursive: true });
        }

        // Write drift.toml
        fs.writeFileSync(configPath, DEFAULT_DRIFT_TOML, 'utf-8');
        process.stdout.write(`Created ${configPath}\n`);

        // Initialize NAPI (creates drift.db)
        const napi = loadNapi();
        napi.driftInitialize(undefined, projectRoot);
        process.stdout.write(`Initialized drift.db in ${driftDir}\n`);

        // Run initial scan + analyze so the DB is populated immediately
        process.stdout.write('\nRunning initial scan...\n');
        const scanResult = await napi.driftScan(projectRoot);
        process.stdout.write(`Scanned ${scanResult.filesTotal} files (${scanResult.filesAdded} added)\n`);

        process.stdout.write('Running analysis pipeline...\n');
        const analyzeResults = await napi.driftAnalyze();
        const totalMatches = analyzeResults.reduce((sum, r) => sum + r.matches.length, 0);
        process.stdout.write(`Analysis complete: ${analyzeResults.length} files, ${totalMatches} patterns detected\n`);

        // CH-01/02/03: Initialize Cortex memory system
        const cortexDir = path.join(projectRoot, '.cortex');
        if (!fs.existsSync(cortexDir)) {
          fs.mkdirSync(cortexDir, { recursive: true });
        }
        process.stdout.write('\nInitializing Cortex memory system...\n');
        try {
          const cortexDbPath = path.join(cortexDir, 'cortex.db');
          const cortexClient = await CortexClient.initialize({ dbPath: cortexDbPath });
          const health = await cortexClient.healthReport();
          process.stdout.write(`Cortex initialized: ${cortexDbPath}\n`);
          process.stdout.write(`  Status: ${health.overall_status ?? 'ready'}\n`);
          process.stdout.write(`  Subsystems: ${health.subsystems?.length ?? 0} active\n`);
        } catch (cortexErr) {
          process.stdout.write(`Cortex init skipped: ${cortexErr instanceof Error ? cortexErr.message : cortexErr}\n`);
        }

        process.stdout.write('\nDrift is ready! Try `drift check` or `drift status` to see results.\n');
        process.exitCode = 0;
      } catch (err) {
        process.stderr.write(`Error: ${err instanceof Error ? err.message : err}\n`);
        process.exitCode = 2;
      }
    });
}
